@namespace CommandCentre.Components.Home

@using CommandCentre.Models
@using CommandCentre.Services

@implements IDisposable

@inject RepoService RepoService

<Panel Title="üîÄ Git Changes Status" BorderColor="@Color.Green" Width="25">
    <Rows>
        @foreach (var repo in _repos)
        {
            <Columns>
                <Markup Content="@($"{repo.Name}:")" Foreground="@Color.Grey" />
                <Markup Content="@GetGitStatusMarkup(_repoStatuses[repo.Name])" />
            </Columns>
        }
    </Rows>
</Panel>

@code {
    private List<RepoInfo> _repos = new();
    private Dictionary<string, RepoStatus> _repoStatuses = new();
    private bool _disposed = false;

    protected override async Task OnInitializedAsync()
    {
        _repos = RepoService.GetAllRepos();

        foreach (var repo in _repos)
        {
            _repoStatuses[repo.Name] = new RepoStatus 
            { 
                Name = repo.Name, 
                HasChanges = false, 
                ChangeCount = 0,
                IsLoading = true 
            };
        }

        await LoadGitStatuses();
    }

    private async Task LoadGitStatuses()
    {
        if (_disposed) return;

        foreach (var repo in _repos)
        {
            if (_disposed) return;
            
            await LoadSingleRepoStatus(repo);
            await InvokeAsync(StateHasChanged);
            
            await Task.Delay(100); // Small delay to prevent overwhelming
        }
    }

    private async Task<RepoStatus> LoadSingleRepoStatus(RepoInfo repo)
    {
        if (_disposed) return new RepoStatus { Name = repo.Name, HasChanges = false, ChangeCount = 0, IsLoading = false };
        
        try
        {
            var status = await GetRepoStatus(repo);
            
            if (!_disposed)
            {
                _repoStatuses[repo.Name] = status;
            }
            
            return status;
        }
        catch (Exception ex)
        {
            // Console.WriteLine($"Error checking git status for {repo.Name}: {ex.Message}");
            
            RepoStatus errorStatus = new RepoStatus 
            { 
                Name = repo.Name, 
                HasChanges = false, 
                ChangeCount = 0
            };
            
            if (!_disposed)
            {
                _repoStatuses[repo.Name] = errorStatus;
            }
            
            return errorStatus;
        }
    }

    private async Task<RepoStatus> GetRepoStatus(RepoInfo repo)
    {
        @* ToDo: doesnt fully work, need to look into it really, maybe change to sync status like below*@
        <!--
            private string GetSyncStatus(RepoInfo repo)
            {
                var status = GitHubService.GetSyncStatus(repo);
                return status switch
                {
                    SyncStatus.UpToDate => "‚úÖ Up to date",
                    SyncStatus.Behind => "‚¨áÔ∏è Behind",
                    SyncStatus.Ahead => "‚¨ÜÔ∏è Ahead",
                    _ => "‚ùì Unknown"
                };
            }
         -->

        var output = await RunBashCommand($"cd '{repo.Path}' 2>/dev/null && git status --porcelain 2>/dev/null || echo ''");
        var hasChanges = !string.IsNullOrWhiteSpace(output);
        
        return new RepoStatus
        {
            Name = repo.Name,
            HasChanges = hasChanges,
            ChangeCount = hasChanges ? output.Split('\n', StringSplitOptions.RemoveEmptyEntries).Length : 0,
            IsLoading = false,
            IsActive = RepoService.HasActiveDirectory(repo)
        };
    }

    private string GetGitStatusMarkup(RepoStatus status)
    {
        if (status.IsLoading) return "‚è≥";
        else if (!status.IsActive) return "‚ùì";

        return status.HasChanges ? "üö®" : "‚úÖ";
    }

    private async Task<string> RunBashCommand(string command)
    {
        string fileName;
        string arguments;
        if (OperatingSystem.IsWindows())
        {
            fileName = "cmd.exe";
            arguments = $"/C {command}";
        }
        else
        {
            // Use bash for Unix-like systems
            fileName = "/bin/bash";
            arguments = $"-c \"{command}\"";
        }

        CommandInfo commandInfo = new CommandInfo
        {
            fileName = fileName,
            arguments = arguments,
            useShellExecute = false,
            redirectStandardOutput = true,
            redirectStandardError = true,
            createNoWindow = true
        };
        var (output, error, exitCode) = await new CommandService().RunAsyncCommand(commandInfo);

        return string.IsNullOrWhiteSpace(output) ? error.Trim() : output.Trim();
    }

    public void Dispose()
    {
        _disposed = true;
    }

    private class RepoStatus
    {
        public string Name { get; set; }
        public bool HasChanges { get; set; }
        public int ChangeCount { get; set; }
        public bool IsLoading { get; set; } = false;
        public bool IsActive { get; set; } = false;
    }
}